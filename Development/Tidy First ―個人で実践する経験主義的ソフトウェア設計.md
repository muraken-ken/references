# Tidy First? ―個人で実践する経験主義的ソフトウェア設計

## イントロダクション

- 「ギークが世界で安全に感じることを助ける」
  - ギークは安全でない方法でソフトウェアを設計することがある。安全でない行動＝不安
  - 安全に設計する方法を学んでもらう

## 第I部　整頓

### 1章　ガード節

```
if (条件)
  if (not 他の条件)
    何らかのコード
```

```
if (not 条件) return
if (他の条件) return
    何らかのコード
```

- コードの細部に入る前に、念頭に置くべき事前条件がある

### 2章　デッドコード

- 実行されないコードは消すだけ

### 3章　シンメトリーを揃える

- コードは有機的に成長する
  - 多くの人が関係する
    - コードのスタイル、書き方が揃えたい

```
foo()
  return foo if foo not nil
  foo := ...
  return foo

foo()
  if foo is nil
    foo := ...
  return foo

# トリッキー
foo()
  return foo not nil
    ? foo
    : foo := ...

#代入が式であると仮定すると二重にトリッキー
foo()
  return foo := foo not nil
    ? foo
    : ...    

#条件が隠されていて更にトリッキー
foo()
  return foo := foo || ...
```

### 4章　新しいインターフェイス、古い実装

- 透過的なインターフェイス
  - ソフトウェア設計における最小単位の本質
  - 振る舞いを変えたい時に変更が簡単になる
- 後からコーディングする
  - 必要な中間結果がすべて揃っているかのように、ルーチンの最終行から始める
- テストファーストでコーディングする
  - 成功しなければいけないテストから始める
- ヘルパーを設計する
  - ○○を行うルーチン、オブジェクト、サービスがあれば、残りは簡単になる

### 5章　読む順番

- コードの読み手が遭遇したいと思う順番に並べよう
  - 正解はない
  - 自分の経験と判断で
- 整理と順番の入れ替えは別に
  - いくつかの言語では順番が重要

### 6章　凝集の順番

- 結合しているコードは隣り合わせにする
- cost(分離)＋cost(変更) ＜ cost(結合)＋cost(変更)
- 実行が難しい
  - 知識面
  - 時間・金銭面
  - 関連性の関係
- 整頓によって凝集度を高めれば、変更が容易になり分離の妨げを取り除ける

### 7章　変数宣言と初期化を一緒の場所に移動する

- 変数と初期化が離れると初期化の時に変数のコンテキストを忘れてしまう

```
fn()
  int a
  ... aを使わない何らかのコード
  a = ...
  int b
  ... さらに別のコード
  b = ...a...
  ...bを使っているなんらかのコード
```

```
fn()
  int a = ...
  ... aを使わない何らかのコード
    ... さらに別のコード
  int b = ...a...
  ...bを使っているなんらかのコード
```

### 8章　説明変数

‐ 式は成長する

```
return new Point(
  ...大きな長い式...
  ...他の大きな長い式...
)
```

```
x := ...大きな長い式...
y := ...他の大きな長い式...
return new Point(x, y)
```

### 9章　説明定数

- リテラル定数を使わず、シンボリック定数を使おう

```
if response.code = 404
  ...hogehoge...
```

```
PAGE_NOT_FOUND := 404
if response.code = PAGE_NOT_FOUND
  ...hogehoge...
```

### 10章　明示的なパラメーター

```
prams = { a: 1, b: 2 }
foo(params)

function foo(params)
  ...params.a...params.b...
```

```
function foo(params)
  foo_body(params.a, params.b)

function foo_body(a, b)
  ...a...b...
```

### 11章　ステートメントを小分けにする

- おおきなチャンクのコード
  - 処理の間に空行を入れ、ステートメントを小分けにする

### 12章　ヘルパーを抽出する

- ルーチン内；明確な目的を持ち、他のコードとの相互作用が限られているコードブロック
  - ヘルパールーチンとして抽出する（メソッドの抽出）

```
routine()
  ...変更しない部分...
  ...変更する部分...
  ...変更しない部分...
```

```
helper()
  ...変更する部分...

routine()
  ...変更しない部分...
  helper()
  ...変更しない部分...
```

### 13章　ひとかたまり

- 細かく分割されているために理解しにくいコード
  - 長くて繰り返しの引数リスト
  - 繰り返しのコード、特に繰り返しの条件式
  - ヘルパールーチンの良くない名前付け
  - 共有の可変データ構造

### 14章　説明コメント

- コードから読み取れないことを書いておく
- ありがちな疑問に先回りして回答しておく

### 15章　冗長なコメントを削除する

- コードに書いてあることをそのまま書いてあるコメントは消す
- 整頓によって冗長なコメントになる場合も整理する

```
if (generator)
  ...ジェネレーターをセットアップするコードのかたまり...
else
  # ジェネレーターがない場合、デフォルトを返す
  return getDefaultGenerator()
```

```
if (! generator)
  # ジェネレーターがない場合、デフォルトを返す ← 冗長
  return getDefaultGenerator()

...ジェネレーターをセットアップするコードのかたまり...
```

## 第II部　管理術

- 整頓はソフトウェア設計
  - いつ整頓を始めるか？
  - いつ整頓を止めるか？
  - どのように整頓するか？
    - コードの構造の変更
    - 振る舞いの変更

### 16章　分けて整頓する

- 堂々巡りの酷い例
  1. 整頓を振る舞いの変更と一緒に入れる
  2. プルリクエストが長いと文句
  3. 整頓を独立したPRとして、振る舞いの変更と分ける
  4. 整頓のPRが無駄だという
  5. 1に戻る

- ステートメントを小分けにする
- 説明ヘルパーができ、振る舞いの変更が容易いになる
- 変更を複数のPRに分けて、合わせて整頓も行う
- PRの大小については、トレードオフに気をつける
  - 大きなPR：レビュワーが有意義なフィードバックが難しい
  - 小さいPR：枝葉末節にとらわれすぎるリスクあり

### 17章　連鎖

- ガード節
  - 条件を説明ヘルパーに置き換え、説明変数に抽出
- デッドコード
  - 読む順番、凝集の順番の並べ替え方が見えるかもしれない
- シンメトリーを揃える
  - 関連するコードを読む順番にまとめられる
- 新しいインターフェイス、古い実装
  - 新しいインターフェイスを使う場合、自動化ツールがないと１つずつ変換が必要になる（ファンアウト）
- 読む順番
  - シンメトリーを揃える方法が見えてくるかもしれない
- 凝集の順番
  - 凝集の順番にグループ化された要素は、子要素に抽出する候補となる
- 説明変数
  - 説明変数への代入の右側は、説明ヘルパーの候補だ
- 説明定数
  - 説明定数を抽出することは、凝集の順番につながる
- 明示的なパラメーター
  - パラメーターセットをオブジェクトに集約し、コードをオブジェクトに移動できるかもしれない
- ステートメントを小分けにする
  - 小分けにしたチャンクに説明コメントを付けられる
  - チャンクを説明ヘルパーとして抽出してもよい
- ヘルパーを抽出する
  - ガード節、説明定数、説明変数の取り入れ、冗長なコメントの削除ができる
- ひとかたまり
  - 大きくて、見るからに散らかったものを作ってしまったら整頓する
- 説明コメント
  - 情報は、説明変数、説明定数、説明ヘルパーでコード内に情報を移す
- 冗長なコメントを削除する
  - 読む順番や明示的なパラメータが見えてくる

### 18章　バッチサイズ

- 検討すべきこと
  - どれだけ整頓するか？
  - どれだけの整頓ならば、統合してデプロイが簡単になるか？

- バッチあたりの整頓の量を増やした場合のコスト
  - 衝突
    - 他の人の作業とのコンフリクト
  - 相互作用
    - 意図せず振る舞いを変える可能性が高くなる
  - 先行投資
    - 不要な整頓

- 整頓はレビューのコストを減らす効果もある

### 19章　リズム

- リズムの管理
  - 小さく変更する（個人のソフトウェア設計：数分～1時間）

### 20章　絡まりを解きほぐす

- 現状
  - どんな振る舞いの変更が必要かをすべて理解している
  - どんな整頓が振る舞いの変更を簡単にするかを理解している
  - 整頓と変更がこんがらがってぐちゃぐちゃになっている

- 進行中の作業を破棄して初めからやり直し、先に整頓する

### 21章　先に整頓、あとに整頓、改めて整頓、整頓しない

- 整頓しない
  - このコードを二度と変更しない
  - 設計の改善から学ぶことは何もない
- 改めて整頓
  - すぐに見返りがない大きなかたまりの整頓を抱えている
  - 整頓を完了することで最終的には見返りがある
  - 小出しに整頓できる
- あとに整頓する
  - 将来の整頓まで待つとかえって高くつく
  - あとに整頓しないとやりきった感が得られない
- 先に整頓する
  - すぐに見返りがある
    - 理解が向上する
    - 安く変更できる
  - 何をどのように整頓すれば良いかわかっている

## 第III部　理論

- 理論
  - ソフトウェア設計とは何か？
  - ソフトウェア設計がソフトウェア開発と運用のコストにどのように影響するか、またソフトウェア開発と運用コストがどのようにソフトウェア設計に影響するか？
  - ソフトウェア構造への投資と投資しないことのトレードオフは何か？
  - ソフトウェアの構造を変更するか、また変更の方法を決定するために、どのような経済性の原則、人間性の原則が使えるか？

### 22章　要素を役立つように関係づける

- ソフトウェア設計とは？
  - 要素を役立つように関係づけること

- 要素
  - トークン
    - 式
      - ステートメント
        - 関数
          - オブジェクト／モジュール
            - システム
- 関係づける
  - 呼び出す
  - 公開する
  - 待ち受ける
  - 参照する（変数の値を取得する）
- 役立つように
  - マシン命令と全体のあいだに中間的な要素を作りながら設計すると、中間的な要素は相互に利益をもたらすようになる。

- 設計
  - 要素
  - その関係性
  - そこから生み出される利益
- 設計者ができること
  - 要素の作成と削除
  - 関係性の作成と削除
  - 関係性が生み出す利益の増加
- システムの構造
  - 要素の階層
  - 要素間の関係性
  - その関係性から生まれる利益

### 23章　構造と振る舞い

- ソフトウェアが価値を生み出す方法
  - 今日ソフトウェアが行うこと
    - 入出力ペア
    - 不変条件
  - 明日ソフトウェアに行なわせることができそうな新しいこと
    - オプショナリティ

- オプションの価値を下げること
  - 重要な従業員が辞める
  - 顧客と距離を置く
  - 変更コストが跳ね上がる

### 24章　経済性：時間価値とオプショナリティ

- ギークな要求とお金の要求がぶつかるとお金が勝つ
  - 今日の1ドルは、明日の1ドルより価値がる
    - 早く稼ぎ、後で使う
  - カオスな状況では、モノよりオプションの方が優れている
    - 不確実性については、オプションを作る
- ソフトウェア設計
  - 「すぐに稼ぐ／あとで使う」と「モノではなくオプションを作る」という要求を調和させる必要がある

### 25章　明日の1ドルより今日の1ドル

- お金の価値
  - いつなのか？
  - どれくらい確実か？
- 明日の1ドルより今日の1ドル
  - 使えない。つまり価値がない
  - 投資できない。今日もらうよりは価値が低くなる
  - 実際に入手できない可能性がある

- 本書の範囲でお金の時間価値が推奨する
  - 先に整頓するよりもあとに整頓する＝すぐにお金が手に入り、あとでお金を使うことになる
  - 先に整頓する方が安価な場合は先に整頓する
- 数分から数時間の規模だとキャッシュフローには大きな影響は与えないが、「時間価値の影響」は大事な原則

### 26章　オプション

- 将来のディスカウントキャッシュフローの合計
  - より早く、より高い確率で、より多くのお金を稼ぐ
  - より遅く、より低い確率で、より少ないお金を費やす

- 「次にどのような振る舞いを実装できるか」
  - 実装する前から価値がある
  - 振る舞いが多ければ多いほど価値がある
  - 価値がある振る舞いが多ければ多いほど価値がある
  - オプションを残せば、どの振る舞いの価値が最大化されるかを気にする必要はない
  - 価値予測の不確実性が高いほど、オプションの価値は高い

- 金融オプションのパラメータ
  - 購入できる原資産となるもの
  - 原資産の価値（変動性も含む）
  - オプションのプレミアム（本日付けの価値）
  - オプションの残存期間
- ソフトウェア設計にとっては
  - 今日の設計は、明日振る舞いの変更を「購入」できるオプション
    - 振る舞いの変更の価値が変動する可能性は高ければ高いほど良い
    - 開発を長く続けられるほどよい
    - 将来もっと安く開発できるに越したことはないが、価値に占める割合は低い
    - オプションを作るために行う設計は少ければ少ないほどよい

### 27章　オプションvs キャッシュフロー

- ディスカウントキャッシュフロー：より早く確実にお金を稼ぎ、あとでお金を使う
- オプション：今お金を使って、あとでお金を稼ぐ

- 先に整頓する
  - cost(整頓)＋cost(整頓のあとに振る舞いを変更) ＜ cost(整頓せずに振る舞いを変更)
- あとで整頓する
  - cost(整頓)＋cost(整頓のあとに振る舞いを変更) ＞ cost(整頓せずに振る舞いを変更)

- ソフトウェア設計のタイミングやスコープに関するインセンティブを意識することに慣れる

### 28章　可逆的な構造変更

- ダサい髪型：髪は伸びる
  - 可逆的な変更
- ダサいタトゥー：元には戻せない
  - 不可逆的な変更
    - レビュー、ダブルチェック、トリプルチェックが大きな意味を持つ
    - デメリットを避けたい

- 可逆的な決定＝ソフトウェア設計（すぐに元に戻せる）
  - 決定にメリットがある
- 可逆的でない設計変更
  - 小さくリスクを減らす取り組み

### 29章　結合

- 結合
  - 1つの修正に2ヵ所以上の修正が必要＝結合している
- 問題となる結合の特性
  - 1-N：1つの修正に対しN個の修正が必要となる
  - カスケード：1つの修正が、他の修正と伝搬する
- 整頓のコストにも結合が関わる

### 30章　コンスタンチンの等価性

- ソフトウェアはモノであり、一度作られたら変更されず永久機関のように動き続けるもの
  - ソフトウェアの実際の姿、あるべき姿とは正反対

- コンスタンチンの等価性
  - cost(ソフトウェア) ~= cost(変更)
  - ソフトウェアのコストは、それを変更するコストとほぼ等しい
- ソフトウェアの変更コスト ~= 大きな変更のコストの合算
  - cost(変更) ~= cost(大きな変更)
  - cost(大きな変更) ~= 結合
  - cost(ソフトウェア) ~= 結合

### 31章　結合vs分離

- ディスカウントキャッシュフロー
  - 多少の結合があっても早く動かす

- 完全に全てを分離することは不可能
  - 常に結合と分離のトレードオフ（掛かるコストも含め）にいる

### 32章　凝集

- 結合した要素を独自の子要素にまとめる
  - サブモジュールを作って関数を持たせる
  - ヘルパー関数
- 結合していない要素を別な場所へ移す
  - お互いに結合しているサブモジュールを作って移動させる
  - 少しづつ移動させるのが大事（一気に動かす＝不可逆な変更になりうる）

### 33章　結論

- 先に整頓するか？
  - コスト：整頓によって...
    - コストが小さくなる
    - コストの発生時期が遅くなる
    - コストが発生する可能性が低くなる
  - 収益：整頓によって...
    - 収益が大きくなる
    - 収益を手にする時期が早くなる
    - 収益を生む可能性が高くなる
  - 結合
    - 整頓によってより少ない要素の変更となるか
  - 凝集
    - 整頓によって変更が必要な要素が、より小さく、もっと集中した範囲になるか
  
  - ソフトウェア設計を日々のビジネスの戦略的プランニングの一部とすれば、ビジネスとテクノロジーの溝を埋める役割を果たすことができる
